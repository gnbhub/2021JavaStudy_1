## 오류와 예외
#### 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있다. 이러한 결과를 초래하는 원인을 프로그램 오류(error)라고 한다.

#### 발생 시점에 따라
#### __컴파일 오류(compile-time error)__ : 컴파일 시에 발생하는 에러
#### __실행 오류(runtime error)__ : 실행 시에 발생하는 에러

#### 컴파일 오류는 개발 환경에서 대부분 원인을 알 수 있다.
#### 발생한 컴파일 오류를 모두 수정해야 프로그램이 정상적으로 실행되므로, 문법적으로 오류가 있다는 것을 바로 알 수 있다.

#### 하지만 프로그램 실행 중에 발생하는 오류는 예측하기 어려운 경우가 많고, 프로그램이 비정상 종료되면서 갑자기 멈춰 버린다. 자바에서는 실행 시(runtime) 발생할 수 있는 프로그램 오류를 '시스템 오류(error)'와 '예외(exception)' 두 가지로 구분하였다.
***
## Object - Throwable
### 시스템 오류(Error)
#### 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
#### 개발자 영역 X, Serious(심각) 한 손상
## 예외(Exception)
#### 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
#### Mild(덜 심각) 한 손상

#### 오류 클래스는 모두 Throwable 클래스에서 상속받는다. Error 클래스의 하위 클래스는 시스템에서 발생하는 오류를 다루며 프로그램에서 제어하지 않는다.

#### 프로그램에서 제어하는 부분은 Exception 클래스와 그 하위에 있는 예외 클래스이다.
***
## 예외 클래스(Exception 클래스)
## Exception
![Exception-Class](https://user-images.githubusercontent.com/74337331/120188243-d6b09100-c250-11eb-8b67-89c70c802824.png)
### IOException : 입출력 예외 처리 (컴파일러 인식, 컴파일에서 에러) - FileNotFoundException, SocketException
### RuntimeException : 실행 오류 예외 처리 (컴파일은 되지만 실행 X - 컴파일러 인식 X)
### RuntimeException 클래스들은 주로 개발자의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.

#### 배열의 범위를 벗어난다던가(IndexOutOfBoundsException),
#### 값이 null인 참조 변수의 멤버를 호출하려 했다던가(NullPointerException),
#### 클래스 간의 형 변환을 잘못했다던가(ClassCastException),
#### 정수를 0으로 나누려고(ArithmeticException) 하는 경우에 발생한다.

#### __Exception 클래스들은 주로 외부의 영향으로 발생하는 경우가 많다.__

#### 존재하지 않는 파일의 이름을 입력했다던가(FileNotFoundException),
#### 실수로 클래스의 이름을 잘못 적었다던가(ClassNotFoundException),
#### 또는 입력한 데이터 형식이 잘못된(DataFormatException) 경우에 발생한다.
***
## 예외 처리하기
## 예외 처리(exception handling)

### 정의 : 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성
### 목적 : 프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지하는 것
#### 예외 처리를 한다고 해서 프로그램의 예외 상황 자체를 막을 수는 없다.
#### 하지만 예외 처리를 하면 예외 상황을 알려주는 메시지를 볼 수 있고, 프로그램이 비정상 종료되지 않고 계속 수행되도록 만들 수 있다.

***
## try catch
```
try {
    예외가 발생할 수 있는 코드 부분
} catch(처리할 예외 타입1 e1) {
    try 블록 안에서 예외1가 발생했을 때 예외를 처리하는 부분
} catch(처리할 예외 타입2 e2) {
    try 블록 안에서 예외2가 발생했을 때 예외를 처리하는 부분
} catch(Exception e) {
    try 블록 안에서 예외가 발생했을 때 예외를 처리하는 부분
}
```
try 블록에는 예외가 발생할 가능성이 있는 코드를 작성한다.
만약 try 블록 안에서 예외가 발생하면 바로 catch 블록이 수행된다.
catch 문의 괄호 안에 쓰는 예외 타입은 예외 상황에 따라 달라진다.

하나의 try 블록 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블록이 올 수 있으며, 이 중 발생한 예외의 종류와 일치하는 단 한 개의 catch 블록만 수행된다.

모든 예외 클래스는 Exception 클래스의 하위 클래스이므로 catch 블록의 괄호 안에 Exception 클래스 타입의 참조 변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch 블록에 의해서 처리된다.

가장 최상위 클래스인 Exception 클래스는 가장 마지막 블록에 위치해야 한다.
## try catch finally 
```
try {
    예외가 발생할 수 있는 부분
} catch(처리할 예외 타입 e) {
    예외를 처리하는 부분
} finally {
    항상 수행되는 부분
}
```
프로그램에서 사용한 리소스는 프로그램이 종료되면 자동으로 해제된다.
하지만 끝나지 않고 계속 수행되는 서비스 같은 경우에 리소스를 여러 번 반복해서 열기만 하고 닫지 않는다면 문제가 발생한다.
사용한 시스템 리소스는 사용 후 반드시 close() 메서드로 닫아 주어야 한다.

프로그램이 정상적으로 종료된 경우에도 열어 놓은 파일 리소스를 닫아야 하고, 비정상 종료된 경우에도 리소스를 닫아야 한다.
따라서 try 블록뿐 아니라 catch 블록에도 close( ) 메서드를 사용해야 한다.

이때 사용하는 블록이 finally이다. try 블록이 수행되면 fianally 블록은 어떤 경우에도 반드시 수행된다. try나 catch 문에 return 문이 있어도 수행된다.

따라서 각 블록마다 리소스를 해제하지 않고 finally 블록에서 한 번만 해제해 주면 된다. 예외가 발생한 경우에는 'try-catch-finally' 순으로 실행되고, 예외가 발생하지 않은 경우에는 'try-finally' 순으로 실행된다.

***
## __예외 발생시키기__
#### 키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있으며, 방법은 아래와 같다.

먼저 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만들고
키워드 throw를 이용해서 예외 발생

#### Exception e = new Exception("고의로 발생시킴");
#### throw e;
## 예제
`` java
class ExceptionEx9 {
  public static void main(String args[]) {
      try {
          Exception e = new Exception("고의로 발생시킴");
          throw e; // 예외를 발생시킴
          // throw new Exception("고의로 발생시킴"); --> 위에 두줄을 한줄로 표현

      }catch (Exception e){
          System.out.println("예외메세지 : " + ae.getMessage());
          e.printStackTrace();
      }
      System.out.println("프로그램이 정상 종료되었음." );
  }
}
```
 실행결과

예외메세지 : 고의로 발생시킴
java.lang.Exception: 고의로 발생시킴
    at ExceptionEx9.main (ExceptionEx9.java:4)
프로그램이 정상 종료되었음
```
#### 자바의 예외처리에 대해서 알아보았다. 사실 예외처리는 자바에서 좀 난이도가 있는 부분에 속한다.

#### 보통 프로그래머의 실력을 평가 할 때 이 예외처리를 어떻게 하고 있는지를 보면 그 사람의 실력을 어느정도 가늠해 볼 수 있다고들 말한다. 예외처리는 부분만 알아서는 안되고 전체를 관통하여 모두 알아야만 정확히 할 수 있기 때문이다.







